# Promise 实现原理及应用场景
* 1、大话
* 2、应用场景
* 3、基本构建
* 4、扩展

-- --
## 大话
&emsp;&emsp;Promise中文译为承诺。承诺在人类的世界中是很有分量的一件事物，一般我们不会轻易的向别人承诺，
但一旦做出承诺，我们都会尽自己所能去完成所保证的事情，即使不能完成我们也会给我们承诺的对象以及时的反馈。<br/>
&emsp;&emsp;生活中，承诺构建其实比较简单，往往我们都只是向别人承诺一件事情，然后去完成。但在多人或者多
公司的业务中，常常会遇到承诺链的问题，比如资金链的流向：首家公司向下家公司承诺项目成功后向下家公司输入一
笔资金，而下家公司又向他的下家公司承诺在获得这笔资金之后他们的项目完成也会向下家公司输入一笔资金，以此类
推，如果各个公司的项目没有问题，那么这个承诺链就完美结束，而一旦其中一家公司有问题，那么这个资金链就断了，
承诺链也随之断裂。<br/>
&emsp;&emsp;一般来说承诺的走向是不可逆的，一旦承诺，要么完成承诺，要么完成不了而向承诺的对象反馈原因。
从计算机的角度来看，实际上我们是用异步操作来实现一个同步的过程。所谓异步，也就是说异步的操作，我们不能直
接干预，只能控制其启动和获取其反馈结果，当多个异步事件启动时，如果下一个异步事件的启动需要上一步的异步事
件反馈作为必要条件，那么这一过程其实就是一个同步操作，也就是我们所要讲的Promise。
-- --
## 应用场景
&emsp;&emsp;作为异步操作的解决方案，Promise在web端和nodejs服务端都有很广泛的应用。
> &emsp;&emsp;在前端，http的请求应答模式是典型的异步操作，我们只能控制ajax的请求和获取服务端的响应，因此promise非常
适合ajax请求的封装，更进一步，我们甚至可以在dom操作和服务端接口层之间利用promise构建一层api层，或者基于钩子
原理利用promise来封装第三方jssdk的工具类<br/>
> &emsp;&emsp;在服务端，由于nodejs的非阻塞io特点，使得异步操作在服务端这种io密集型场景得到大量运用，当我们
频繁地使用文件操作时，Promise可以完美解决回调地狱的问题，甚至可以支持“多路汇合”场景——下一步的异步操作需要多个上一步
的异步操作结果。
-- --
## 基本构建
&emsp;&emsp;基于“大话”中的描述，我们可以很容易抽象出promise的基础是一个事件队列，它可以和状态共同构成我们
想要的结果：
   ``` javascript
   var Promise = function() {
       var state = "";
       var event_list = [];
   }
   ``` javascript
